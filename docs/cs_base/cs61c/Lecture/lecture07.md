# CS61C Lecture 07: RISC-V intro

## 一、计算机抽象层次
```
高级语言 → 汇编语言 → 机器码 → 微架构 → 物理电路
```
**关键特性**：每一层隐藏下层实现细节，指令集架构（ISA）是软硬件的接口契约

## 二、RISC-V 核心优势
- **开源自由**：BSD协议允许任意修改和商用
- **模块化设计**：基础指令集 + 可扩展模块（I/M/A/F/D等）
  - RV32I（基础整数指令集）
  - M（乘除扩展）、A（原子操作）、F/D（单/双精度浮点）
- **精简高效**：典型RISC特征，对比x86（CISC）：
  - 定长32位指令（RV32）
  - 仅load/store访问内存
  - 32个通用寄存器
- **应用广泛**：IoT → 超算的全生态覆盖

## 三、寄存器系统详解
1. **基础配置**：
   - 32个通用寄存器（x0-x31）
   - x0特殊寄存器：硬连线零值，写操作无效
   - 寄存器宽度：RV32（32bit）、RV64（64bit）

1. **ABI 别名规范**：

| 寄存器   | 别名    | 用途    |
| ----- | ----- | ----- |
| x0    | zero  | 恒零值   |
| x1    | ra    | 返回地址  |
| x2    | sp    | 栈指针   |
| x5-x7 | t0-t2 | 临时寄存器 |
| x8-x9 | s0-s1 | 保存寄存器 |


3. **核心特性**：
   - **无类型系统**：操作决定数据处理方式（符号扩展/补码运算）
   - **使用限制**：高频访问要求，需合理分配寄存器资源

## 四、指令格式与类型
### 1. 算术指令
```asm
add  x1, x2, x3   # x1 = x2 + x3（寄存器-寄存器）
sub  x4, x5, x6   # x4 = x5 - x6
addi x7, x8, -20  # x7 = x8 + (-20)（立即数减法替代方案）
```
**立即数特性**：
- 12位有符号数（范围：-2048 ~ 2047）
- 无subi指令，负数加法实现减法

### 2. 内存访问指令
```asm
lw  x9, 40(x10)   # x9 = MEM[x10+40]（32bit加载）
sw  x11, 80(x12)  # MEM[x12+80] = x11（32bit存储）
```
**关键限制**：RISC-V采用Load-Store架构，算术指令无法直接操作内存

### 3. 控制流指令
```asm
beq x1, x2, label  # if x1==x2 → jump to label
jal ra, func       # 跳转至func，ra保存返回地址
jalr x0, 0(x1)     # 间接跳转到x1地址
```
**寻址特性**：分支偏移量为12位有符号数 × 2（字节对齐）

## 五、设计原则与优化技巧
1. **伪指令优化**：
   ```asm
   mv   x5, x6     → addi x5, x6, 0
   li   x7, 0x1234 → lui + addi 组合
   ```
   汇编器自动转换伪指令为合法机器码

2. **立即数扩展策略**：
   - 小立即数：直接使用addi
   - 大立即数：lui（加载高20位） + addi/ori（设置低12位）

3. **性能考量**：
   - 4GHz CPU → 0.25ns/cycle，寄存器访问只需1周期
   - 内存访问需数十到数百周期，凸显寄存器优化重要性

## 六、对比实验（x86 vs RISC-V）
```c
// C代码示例
int a = b + 10;
```

**x86实现**：
```asm
mov eax, [b_addr]  ; 内存加载
add eax, 10        ; 直接操作内存值
mov [a_addr], eax
```

**RISC-V实现**：
```asm
lw  t0, b_addr    # 显式加载到寄存器
addi t0, t0, 10   # 寄存器操作
sw  t0, a_addr    # 显式存储结果
```
**关键差异**：RISC-V强制显式数据移动，提升流水线效率


