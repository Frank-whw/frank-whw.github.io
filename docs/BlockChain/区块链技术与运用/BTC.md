# 1. 密码学原理

crypto - currency（加密货币），作为一种基于密码学技术的数字货币形式，其背后依托了多种复杂且精妙的密码学原理，确保了交易的安全性、不可篡改性以及去中心化特性。

## cryptographic hash function（加密哈希函数）

加密哈希函数在区块链领域有着举足轻重的地位，它具备以下关键特性：

1. **collision resistance（抗碰撞性）**：

- 含义：理想情况下，对于不同的输入数据，哈希函数应产生不同的哈希值。很难找到两个不同的输入 x 和 y，使得 H (x) = H (y)。例如，md5 曾是广泛使用的哈希算法，但后来被发现存在碰撞漏洞，即能找到不同数据产生相同 md5 值的情况，这在对安全性要求极高的区块链等场景中是不可接受的。尽管它曾因计算效率高而被大量使用，但因其抗碰撞性不足，逐渐被弃用。

2. **hiding（隐匿性，单向不可逆）**：

- 原理：从哈希值几乎无法反向推导出原始输入数据。并且要求输入空间足够大，数据分布均匀。如果输入空间小或分布不均匀，攻击者就有可能通过蛮力求得能产生特定哈希值的输入。

- 应用：

- **digital commitment/digital equivalent of a sealed envelop（数字承诺 / 密封信封的数字等价物）**：例如在预测类场景中，预测结果不能提前公开。可以先对预测结果进行哈希运算，将哈希值公开，之后再公开原始预测结果，其他人通过对原始结果进行哈希计算并与之前公开的哈希值对比，就能验证结果的一致性和未被篡改。

- **数字签名**：把预测结果作为输入，通过特定的哈希运算得到哈希值，再用私钥对该哈希值进行签名。签名后的信息可用于验证数据来源及完整性。

- **H(x||nonce)**：在结果后拼接一个随机值 nonce。这常用于区块链挖矿等场景，通过改变 nonce 值，使哈希运算结果满足特定条件。例如在比特币挖矿中，通过不断调整 nonce 来使区块头的哈希值满足一定难度要求。

3. **puzzle friendly（谜题友好性）**：

- 特性：哈希值事先不可预测。对于任意给定的哈希值，在不知道输入的情况下，无法通过特定方法快速找到能产生该哈希值的输入数据。

- 应用：

- **挖矿**：以比特币挖矿为例，矿工需要找 nonce，使得 H (block header) <= target（目标值）。这个过程没有捷径，只能大量地去尝试不同的 nonce 值，这就是所谓的 proof of work（工作量证明）。通过这种方式，保证了区块链系统中新区块生成的公平性和安全性。

- **difficult to solve, but easy to vertify（求解困难，但验证容易）**：矿工找到满足条件的 nonce 和哈希值后，其他节点可以很容易地通过重新计算哈希值并与目标值对比来验证其正确性。

- **SHA - 256——secure hash algorithm（安全哈希算法）**：是比特币等区块链项目广泛使用的哈希算法，具有较高的安全性和计算效率，能有效保证区块链中数据的完整性和哈希计算的安全性。

## 签名

在区块链的去中心化环境中，签名机制是确保交易安全和身份认证的关键环节：

- **去中心化特性**：签名机制不依赖于任何中心化的机构来验证身份或授权交易，而是通过密码学原理在网络节点间实现自我验证。

- **（public key，private key）（公钥，私钥）**：这是基于非对称加密算法产生的一对密钥。

- **asymmetric encryption algorithm（非对称加密算法）**：使用一对密钥，即公钥和私钥。与对称加密算法不同，对称加密算法加密和解密使用相同的密钥，而在非对称加密中，加密用公钥，解密用私钥。

- **优势**：公钥不用保密，可以广泛公开传播，私钥只要保存在本地，极大地解决了密钥分发不方便的问题。例如在区块链网络中，每个节点都可以将自己的公钥公开给其他节点，用于接收加密信息或验证签名。

- **类比**：公钥相当于银行卡账号，可公开示人用于接收资金等操作；私钥相当于密码，必须严格保密，只有拥有私钥的人才能对相关资产进行操作。

- **签名与验证**：签名是用私钥对数据（通常是数据的哈希值）进行处理，生成一个签名信息。验证时则是用公钥对签名信息进行验证，以确认数据是否由对应的私钥持有者发出且未被篡改。例如在比特币交易中，交易发起者用自己的私钥对交易信息进行签名，其他节点收到交易后，用发起者的公钥验证签名，从而确定交易的真实性和有效性。

- **a good source of randomness（良好的随机数来源）**：私钥的生成通常基于随机数，这些随机数为签名过程提供了不可预测性，进一步增强了签名的安全性。

比特币一般是对 message 先哈希，然后再签名。这是因为哈希值具有固定长度且能唯一代表原始消息的特征，对哈希值签名比对原始消息直接签名更高效且能保证消息完整性。如果原始消息被篡改，其哈希值会发生变化，而基于原哈希值的签名将无法通过验证。

---

# 2. 数据结构

## 1. Hash Pointers（哈希指针）

哈希指针是区块链数据结构中的一个关键概念，它不仅保存了结构体的地址，还保存了该结构体的哈希值。这一特性使得哈希指针能够检测数据是否被篡改。

在区块链中，一个个的区块通过哈希指针连接形成链表结构。其独特之处在于：“block chain is a linked list using hash pointer”（区块链是使用哈希指针的链表），从创世区块（genesis block）开始，一直连接到最新的区块（most recent block）。

### 好处 - Tamper - Evident Log（防篡改日志）
这种基于哈希指针的链表结构形成了一种防篡改日志。因为每个区块的哈希指针不仅指向了前一个区块的地址，还包含前一个区块内容的哈希值。如果对前面任何一个区块的内容进行篡改，该区块的哈希值就会发生变化。由于后续区块的哈希指针依赖于前序区块的哈希值，所以前面区块的任何改动都会导致后面所有区块的哈希指针发生变化，正所谓 “牵一发而动全身”。这样，区块链中的数据一旦被记录，就很难被篡改而不被发现，保证了数据的完整性和可信度。

## 2. Merkle Tree（默克尔树）
默克尔树是一种特殊的二叉树结构，与普通二叉树的区别在于它使用哈希指针代替普通指针。

### 结构与原理

如给定的图片
![image.png](https://raw.githubusercontent.com/Frank-whw/img/main/blog/202501201737099.png)

所示，默克尔树的底层节点（data blocks）通常是交易（tx），可以是块头或者块身。其中，块头（block header）包含根哈希值，但不包含交易的具体内容；块身（block body）则包含交易的列表。

### 好处 - 数据完整性检测
默克尔树最大的好处在于，只要知道根哈希（root hash），就能检测出下面任何部分是否发生变化。因为默克尔树的构建方式是将底层节点的哈希值两两组合再进行哈希计算，逐层向上，最终得到根哈希。如果底层任何一个数据块（交易）发生改变，其哈希值就会改变，进而导致上层节点的哈希值也依次改变，最终根哈希值也会不同。所以通过对比当前根哈希值与之前记录的根哈希值，就能判断底层数据是否被篡改。

### Merkle Proof（默克尔证明）

默克尔树提供了默克尔证明机制。在比特币（BTC）中，节点分为两类：全节点和轻节点。全节点保存了完整的区块链数据，包括所有的区块头和区块体；而轻节点只保存一个区块头（block header）。

轻节点相当于手机上的比特币客户端，用户通过轻节点发送交易信息（tx）。由于轻节点没有完整的交易数据，所以它会向全节点请求验证。验证过程中，轻节点通过一层一层的 SPV（Simple Payment Verification，简单支付验证），本地计算部分哈希值，并向全节点请求得到其他哈希值，然后向上一直计算到根哈希，最后将计算得到的根哈希与自己保存的区块头中的根哈希值进行比较，以此判断该交易是否被记录在区块链上。轻节点在验证过程中，只能查询到与该交易相关路径中的哈希值。

### 安全性分析
1. **关于篡改证明数据**：有人可能会想，能否为了证明自己的交易已记录在区块链上，却又篡改证明过程中需要用到的其他交易，导致证明失败。实际上这种做法是不可行的。因为在默克尔树结构下，若要修改某个节点数据以达到篡改证明的目的，不仅需要修改该节点本身，还需要修改其上层所有依赖该节点哈希值的节点，直至根节点。这意味着几乎要修改整棵树，甚至影响到整条区块链，从算力消耗上来说是不现实的。
2. **影响证明正确性的因素**：在上述条件下，所提供的默克尔证明中辅助哈希值必然是正确的。因为在正常的区块链网络中，全节点保存的是完整且正确的数据，轻节点从全节点获取的哈希值也是可信的。所以唯一可能影响证明正确性的因素就是验证节点（轻节点）本身，例如其软件实现是否正确、计算过程是否有误等。

### 成员证明与非成员证明
1. **Proof of Membership（成员证明）/Proof of Inclusion（包含证明）**：通过默克尔证明可以高效地验证某个交易是否包含在区块链中。由于默克尔树是二叉树结构，从叶子节点到根节点的路径长度为 log (n)（n 为叶子节点的数量），所以验证过程的时间复杂度为 log (n)，相对比较高效。
2. **Proof of Non - Membership（非成员证明）**：对于证明某个交易不在默克尔树中，传统默克尔树的验证时间复杂度为 n，呈线性关系。但是，如果节点是根据哈希值排好序的（即 sorted merkle tree，排序默克尔树），就可以通过判断某个节点的哈希值在排序中的位置，以及它旁边节点是否相邻，来判断该节点是否在这个树中。不过在比特币的默克尔树中，并不要求节点进行排序。

### 哈希指针的应用限制
哈希指针虽然在区块链数据结构中有诸多优势，但它的应用场景存在一定限制。例如，哈希指针只能用在无环的列表结构中。如果是有环结构，会出现**循环依赖**的问题，导致哈希值计算无法正常完成，破坏了哈希指针基于数据完整性和顺序性的检测机制。


---

