# 1. 密码学原理

crypto - currency（加密货币），作为一种基于密码学技术的数字货币形式，其背后依托了多种复杂且精妙的密码学原理，确保了交易的安全性、不可篡改性以及去中心化特性。

## cryptographic hash function（加密哈希函数）

加密哈希函数在区块链领域有着举足轻重的地位，它具备以下关键特性：

1. **collision resistance（抗碰撞性）**：

- 含义：理想情况下，对于不同的输入数据，哈希函数应产生不同的哈希值。很难找到两个不同的输入 x 和 y，使得 H (x) = H (y)。例如，md5 曾是广泛使用的哈希算法，但后来被发现存在碰撞漏洞，即能找到不同数据产生相同 md5 值的情况，这在对安全性要求极高的区块链等场景中是不可接受的。尽管它曾因计算效率高而被大量使用，但因其抗碰撞性不足，逐渐被弃用。

2. **hiding（隐匿性，单向不可逆）**：

- 原理：从哈希值几乎无法反向推导出原始输入数据。并且要求输入空间足够大，数据分布均匀。如果输入空间小或分布不均匀，攻击者就有可能通过蛮力求得能产生特定哈希值的输入。

- 应用：

- **digital commitment/digital equivalent of a sealed envelop（数字承诺 / 密封信封的数字等价物）**：例如在预测类场景中，预测结果不能提前公开。可以先对预测结果进行哈希运算，将哈希值公开，之后再公开原始预测结果，其他人通过对原始结果进行哈希计算并与之前公开的哈希值对比，就能验证结果的一致性和未被篡改。

- **数字签名**：把预测结果作为输入，通过特定的哈希运算得到哈希值，再用私钥对该哈希值进行签名。签名后的信息可用于验证数据来源及完整性。

- **H(x||nonce)**：在结果后拼接一个随机值 nonce。这常用于区块链挖矿等场景，通过改变 nonce 值，使哈希运算结果满足特定条件。例如在比特币挖矿中，通过不断调整 nonce 来使区块头的哈希值满足一定难度要求。

3. **puzzle friendly（谜题友好性）**：

- 特性：哈希值事先不可预测。对于任意给定的哈希值，在不知道输入的情况下，无法通过特定方法快速找到能产生该哈希值的输入数据。

- 应用：

- **挖矿**：以比特币挖矿为例，矿工需要找 nonce，使得 H (block header) <= target（目标值）。这个过程没有捷径，只能大量地去尝试不同的 nonce 值，这就是所谓的 proof of work（工作量证明）。通过这种方式，保证了区块链系统中新区块生成的公平性和安全性。

- **difficult to solve, but easy to vertify（求解困难，但验证容易）**：矿工找到满足条件的 nonce 和哈希值后，其他节点可以很容易地通过重新计算哈希值并与目标值对比来验证其正确性。

- **SHA - 256——secure hash algorithm（安全哈希算法）**：是比特币等区块链项目广泛使用的哈希算法，具有较高的安全性和计算效率，能有效保证区块链中数据的完整性和哈希计算的安全性。

## 签名

在区块链的去中心化环境中，签名机制是确保交易安全和身份认证的关键环节：

- **去中心化特性**：签名机制不依赖于任何中心化的机构来验证身份或授权交易，而是通过密码学原理在网络节点间实现自我验证。

- **（public key，private key）（公钥，私钥）**：这是基于非对称加密算法产生的一对密钥。

- **asymmetric encryption algorithm（非对称加密算法）**：使用一对密钥，即公钥和私钥。与对称加密算法不同，对称加密算法加密和解密使用相同的密钥，而在非对称加密中，加密用公钥，解密用私钥。

- **优势**：公钥不用保密，可以广泛公开传播，私钥只要保存在本地，极大地解决了密钥分发不方便的问题。例如在区块链网络中，每个节点都可以将自己的公钥公开给其他节点，用于接收加密信息或验证签名。

- **类比**：公钥相当于银行卡账号，可公开示人用于接收资金等操作；私钥相当于密码，必须严格保密，只有拥有私钥的人才能对相关资产进行操作。

- **签名与验证**：签名是用私钥对数据（通常是数据的哈希值）进行处理，生成一个签名信息。验证时则是用公钥对签名信息进行验证，以确认数据是否由对应的私钥持有者发出且未被篡改。例如在比特币交易中，交易发起者用自己的私钥对交易信息进行签名，其他节点收到交易后，用发起者的公钥验证签名，从而确定交易的真实性和有效性。

- **a good source of randomness（良好的随机数来源）**：私钥的生成通常基于随机数，这些随机数为签名过程提供了不可预测性，进一步增强了签名的安全性。

比特币一般是对 message 先哈希，然后再签名。这是因为哈希值具有固定长度且能唯一代表原始消息的特征，对哈希值签名比对原始消息直接签名更高效且能保证消息完整性。如果原始消息被篡改，其哈希值会发生变化，而基于原哈希值的签名将无法通过验证。

---

# 2. 数据结构

## 1. Hash Pointers（哈希指针）

哈希指针是区块链数据结构中的一个关键概念，它不仅保存了结构体的地址，还保存了该结构体的哈希值。这一特性使得哈希指针能够检测数据是否被篡改。

在区块链中，一个个的区块通过哈希指针连接形成链表结构。其独特之处在于：“block chain is a linked list using hash pointer”（区块链是使用哈希指针的链表），从创世区块（genesis block）开始，一直连接到最新的区块（most recent block）。

### 好处 - Tamper - Evident Log（防篡改日志）
这种基于哈希指针的链表结构形成了一种防篡改日志。因为每个区块的哈希指针不仅指向了前一个区块的地址，还包含前一个区块内容的哈希值。如果对前面任何一个区块的内容进行篡改，该区块的哈希值就会发生变化。由于后续区块的哈希指针依赖于前序区块的哈希值，所以前面区块的任何改动都会导致后面所有区块的哈希指针发生变化，正所谓 “牵一发而动全身”。这样，区块链中的数据一旦被记录，就很难被篡改而不被发现，保证了数据的完整性和可信度。

## 2. Merkle Tree（默克尔树）
默克尔树是一种特殊的二叉树结构，与普通二叉树的区别在于它使用哈希指针代替普通指针。

### 结构与原理

如给定的图片
![image.png](https://raw.githubusercontent.com/Frank-whw/img/main/blog/202501201737099.png)

所示，默克尔树的底层节点（data blocks）通常是交易（tx），可以是块头或者块身。其中，块头（block header）包含根哈希值，但不包含交易的具体内容；块身（block body）则包含交易的列表。

### 好处 - 数据完整性检测
默克尔树最大的好处在于，只要知道根哈希（root hash），就能检测出下面任何部分是否发生变化。因为默克尔树的构建方式是将底层节点的哈希值两两组合再进行哈希计算，逐层向上，最终得到根哈希。如果底层任何一个数据块（交易）发生改变，其哈希值就会改变，进而导致上层节点的哈希值也依次改变，最终根哈希值也会不同。所以通过对比当前根哈希值与之前记录的根哈希值，就能判断底层数据是否被篡改。

### Merkle Proof（默克尔证明）

默克尔树提供了默克尔证明机制。在比特币（BTC）中，节点分为两类：全节点和轻节点。全节点保存了完整的区块链数据，包括所有的区块头和区块体；而轻节点只保存一个区块头（block header）。

轻节点相当于手机上的比特币客户端，用户通过轻节点发送交易信息（tx）。由于轻节点没有完整的交易数据，所以它会向全节点请求验证。验证过程中，轻节点通过一层一层的 SPV（Simple Payment Verification，简单支付验证），本地计算部分哈希值，并向全节点请求得到其他哈希值，然后向上一直计算到根哈希，最后将计算得到的根哈希与自己保存的区块头中的根哈希值进行比较，以此判断该交易是否被记录在区块链上。轻节点在验证过程中，只能查询到与该交易相关路径中的哈希值。

### 安全性分析
1. **关于篡改证明数据**：有人可能会想，能否为了证明自己的交易已记录在区块链上，却又篡改证明过程中需要用到的其他交易，导致证明失败。实际上这种做法是不可行的。因为在默克尔树结构下，若要修改某个节点数据以达到篡改证明的目的，不仅需要修改该节点本身，还需要修改其上层所有依赖该节点哈希值的节点，直至根节点。这意味着几乎要修改整棵树，甚至影响到整条区块链，从算力消耗上来说是不现实的。
2. **影响证明正确性的因素**：在上述条件下，所提供的默克尔证明中辅助哈希值必然是正确的。因为在正常的区块链网络中，全节点保存的是完整且正确的数据，轻节点从全节点获取的哈希值也是可信的。所以唯一可能影响证明正确性的因素就是验证节点（轻节点）本身，例如其软件实现是否正确、计算过程是否有误等。

### 成员证明与非成员证明
1. **Proof of Membership（成员证明）/Proof of Inclusion（包含证明）**：通过默克尔证明可以高效地验证某个交易是否包含在区块链中。由于默克尔树是二叉树结构，从叶子节点到根节点的路径长度为 log (n)（n 为叶子节点的数量），所以验证过程的时间复杂度为 log (n)，相对比较高效。
2. **Proof of Non - Membership（非成员证明）**：对于证明某个交易不在默克尔树中，传统默克尔树的验证时间复杂度为 n，呈线性关系。但是，如果节点是根据哈希值排好序的（即 sorted merkle tree，排序默克尔树），就可以通过判断某个节点的哈希值在排序中的位置，以及它旁边节点是否相邻，来判断该节点是否在这个树中。不过在比特币的默克尔树中，并不要求节点进行排序。

### 哈希指针的应用限制
哈希指针虽然在区块链数据结构中有诸多优势，但它的应用场景存在一定限制。例如，哈希指针只能用在无环的列表结构中。如果是有环结构，会出现**循环依赖**的问题，导致哈希值计算无法正常完成，破坏了哈希指针基于数据完整性和顺序性的检测机制。


---

# 3. 协议

## 方案探讨与问题分析

### 方案一：公私钥非对称加密
采用公私钥非对称加密技术，虽能保障交易的安全性，但在数字货币场景下存在严重问题。数字货币本质上是数字化信息，具有可复制性，这就导致了 “花 2 次攻击（double spending attack）”，即双花攻击。攻击者有可能利用数字货币的可复制特性，将同一笔数字资产进行多次花费，破坏了货币交易的唯一性和价值稳定性。因此，数字货币必须防范双花攻击。

### 方案二：中心化存储
该方案通过设立一个中心化的数据库，记录每个标号的货币归属，即记录每一笔钱在谁手上。从理论层面看，这种方式能够解决双花问题，因为中心化数据库可以统一管理和验证每一笔交易，确保货币的唯一性。然而，在实际应用中，这种方法过于繁琐，需要一个强大的中心机构来维护数据库，且容易引发信任问题，例如中心机构可能存在数据篡改、单点故障等风险。

### 方案三：去中心化
去中心化方案旨在构建一个无需依赖中心化机构的数字货币系统，但面临着两个关键问题：
1. **货币发行问题**：在比特币（BTC）系统中，货币发行由挖矿机制决定。挖矿过程不仅仅是简单的计算操作，它还承担着发行新比特币的重要职责。
2. **双花攻击防范问题**：比特币通过所有用户共同维护区块链来解决双花问题。区块链是一种分布式账本，每个参与者（节点）都保存了账本的副本，通过共识机制确保所有账本副本的一致性，从而有效防范双花攻击。

## 比特币交易示例与结构分析
例如，在一个简单的比特币交易流程中：
- **铸币交易（creatCoint）**：产生初始的比特币，如 `creatCoint -> A(10)`，这是一个 coinbase tx（创币交易），其中包含了 A 的公钥的哈希。这意味着 A 获得了 10 个比特币，且这笔交易作为比特币的初始来源，开启了后续的流转。
- **后续交易**：
    - `A -> B(5)`，`A -> C(5)`，这两笔交易由 A 发起，并由 A 使用自己的私钥进行签名。签名的目的是证明交易的真实性和 A 的授权，其他节点可以使用 A 的公钥来验证签名的有效性。
    - `B -> C(2)`，`B -> D(3)`，同样由 B 用私钥签名，表明 B 对这两笔交易的授权。
    - `C -> E(7)`，由 C 签名，展示了比特币在不同用户之间的流转过程。

  

在比特币交易中，每个交易分为输入和输出两部分：
- **输入部分**：需要明确币的来源，即引用之前交易的输出作为本次交易的输入，通过这种方式追溯资金的源头，确保每一笔交易的合法性和连贯性。
- **输出部分**：要给出收款方的公钥，指定这笔比特币的接收者。发送方使用接收方的公钥对交易信息进行加密，只有接收方能够使用自己的私钥解密获取交易内容。同时，发送方用自己的私钥进行签名，接收方以及其他节点可以使用发送方的公钥进行验证，确保交易确实由发送方发起且未被篡改。

  
每个交易的输入输出实际上是一段脚本，公钥也在脚本中指定。比特币脚本通过一种特殊的编程逻辑来验证交易的有效性。例如，A 的输入脚本和前面交易的输出脚本拼接在一起，如果这段拼接后的脚本能够按照比特币脚本的规则正常运行，就说明该交易是正常的。

## 比特币区块链结构
在实际的比特币系统中，每个区块包含了大量的交易，其结构通过 Merkle 树来组织，分为块头（block header）和块身（block body）：

- **块头（block header）**：包含关键信息，如 `version`（版本号，用于标识区块的协议版本）、`hash of previous block header`（前一个区块头的哈希值，通过哈希指针将区块链中的各个区块连接起来，形成链式结构，保证了数据的顺序性和可追溯性）、`merkle root hash`（默克尔树的根哈希值，用于快速验证区块内所有交易的完整性）、`target`（目标哈希值，决定了挖矿的难度，矿工需要找到一个哈希值小于该目标值的区块头，才能获得记账权）、`nonce`（一个 4 字节的随机数，矿工通过不断调整 nonce 值来尝试找到符合要求的哈希值）。通过计算 `H(block header) <= target`（其中 `H` 表示哈希函数），只有满足这个条件的区块头才是有效的。这里的 `nBits` 是一种表示目标值的紧凑格式，用于在不同节点间统一表示目标难度。值得注意的是，只有块头有指向前一个块头的哈希指针，形成了区块链的基本链式结构。那么，有人可能会问，如果只对块头取哈希，而块身不取哈希，如何保证块身内容不被修改呢？实际上，块身中的所有交易通过 Merkle 树结构组织，块头中的 Merkle 根哈希值是根据块身中所有交易计算得出的。如果块身内容发生任何改变，重新计算得到的 Merkle 根哈希值必然会改变，从而导致块头的哈希值改变，使得该区块不再满足 `H(block header) <= target` 的条件，因此 Merkle 根哈希能够保证块身内容的完整性和不被篡改。
- **块身（block body）**：主要包含交易列表，即该区块所打包的所有比特币交易。


比特币网络中的节点分为两种类型：
- **全节点（full node）**：也称为完全验证节点，它保存了完整的区块链数据，包括所有的区块头和区块体，能够独立验证每一笔交易的合法性，参与区块链的构造和维护，对整个区块链网络的安全和稳定起着关键作用。
- **轻节点（light node）**：无法独立验证交易的合法性，因为它没有存储完整的区块链数据，没有参与区块链的实际构造过程。轻节点主要利用查询功能，通过向全节点请求相关信息来验证交易，例如在简单支付验证（SPV）过程中，轻节点通过向全节点获取部分哈希值等信息，结合本地计算来验证交易是否被记录在区块链上。

## 交易写入区块链与共识机制

### 交易如何写入区块链

区块链本质上是一个去中心化的账本，要将交易写入区块链，就需要在分布式网络中的众多节点间达成共识，即对账本内容的一致性认可。这里涉及到分布式共识（distributed consensus）的概念，类似于分布式哈希表（distributed hash table）的全局哈希表结构，其中每个节点都保存了一份 “key - value pair” 形式的账本副本。然而，在分布式系统中达成共识并非易事，存在一些不可能结论：
1. **FLP 定理**：在一个异步（asynchronous）系统里，网络传输时延没有上限，哪怕只有一个用户是故障（faulty）的，也没有办法达成共识。这就好比著名的拜占庭将军问题，在分布式系统中，各个节点就像拜占庭军队中的将军，他们需要在进攻或撤退等决策上达成一致，但由于存在故障节点或恶意节点的干扰，使得达成共识变得极为困难。
2. **CAP 定理**：在分布式系统中，一致性（consistence）、可用性（availability）和容错性（partition tolerance）这三个性质不可能同时满足。在实际应用中，往往需要根据具体场景对这三个特性进行权衡。

  

在比特币系统中，为了在大多数节点是好的，少部分是坏的情况下达成共识，采用了以下方法：
### 比特币的共识机制

1. **投票方式的思考与问题**：
    - **基于账号数量投票**：最初设想通过账号数量来投票决定账本内容的共识。但这种方式存在严重的效率问题，恶意攻击者可能会进行 “行政不作为”，即不断发起攻击并投票，导致正常节点没有时间进行挖矿等有效操作。此外，在比特币系统中创建账号非常容易，这就引发了女巫攻击（sybil attack），攻击者可以创建大量虚假账号来控制投票结果，破坏共识机制。
    - **基于算力投票**：比特币采用了基于算力的投票方式来解决上述问题。在挖矿过程中，矿工需要找到一个合适的 `nonce`，使得 `H(block header) <= target`。这个过程需要大量的计算资源，即算力。只有找到符合要求的 `nonce` 的节点才有权力发布下一个区块，这个权力被称为记账权，即在区块链这个去中心化的账本里写入下一个区块的权利。其他节点收到这个新区块后，会验证该区块的合法性，例如检查 `block header` 的内容，包括 `nBits` 是否正确，确保其符合比特币网络设定的规则和难度要求。
2. **区块的接受与分叉问题**：
    - **区块插入位置与合法性**：新产生的区块必须插在最长合法链上。如果将区块插在中间，不在最长合法链上，就会出现问题。因为节点对区块合法性的判断主要依据前面交易的情况，如果在该区块之后仍有交易，可能会导致双重支付问题，即分叉攻击（forking attack），攻击者试图回滚某个已经发生的交易，从而实现双花。因此，只有拓展最长合法链的区块才会被大多数节点接受。
    - **同时发布合法区块的处理**：当两个节点同时发布合法区块时，比特币网络会看谁能够抢先找到下一个区块。先挖出下一个合法区块且被网络认可的节点，不仅能获得该区块的记账权，还会得到比特币奖励。这就激励了矿工不断提高算力，以争取获得记账权和奖励。
3. **竞争记账权的原因 - 出块奖励**：  
    竞争记账权的主要动力是出块奖励（block reward）。挖出新区块的节点在 `block body` 中会有一个特殊的交易，即铸币交易（coinbase transaction），这是发行新比特币的唯一方法。在比特币系统的初始阶段，每一个区块的出块奖励为 50 BTC，随着时间推移和区块数量的增加，奖励会逐渐减半，如经过 21 万个区块后，奖励变为 25 BTC，目前大约为 12.5 BTC。中本聪在比特币创世区块中首次引入了这种奖励机制，据说比特币第一次与现实世界产生价值交换时，是用 2 万个比特币购买了一个披萨，这标志着比特币从虚拟概念走向了实际应用。需要注意的是，在分叉点上得到的比特币是没有用的，因为只有在最长合法链上的比特币才被整个网络认可和接受。


通过上述基于算力的共识机制，比特币实现了去中心化账本内容的一致性，使得挖矿（mining）这一过程类似于寻找数字黄金，矿工们通过争夺记账权，不断为区块链网络添加新的区块，维护着比特币系统的稳定运行，同时也使得女巫攻击在这种机制下无法对系统造成实质性破坏。


---
# 1. 密码学原理

crypto - currency（加密货币），作为一种基于密码学技术的数字货币形式，其背后依托了多种复杂且精妙的密码学原理，确保了交易的安全性、不可篡改性以及去中心化特性。

## cryptographic hash function（加密哈希函数）

加密哈希函数在区块链领域有着举足轻重的地位，它具备以下关键特性：

1. **collision resistance（抗碰撞性）**：

- 含义：理想情况下，对于不同的输入数据，哈希函数应产生不同的哈希值。很难找到两个不同的输入 x 和 y，使得 H (x) = H (y)。例如，md5 曾是广泛使用的哈希算法，但后来被发现存在碰撞漏洞，即能找到不同数据产生相同 md5 值的情况，这在对安全性要求极高的区块链等场景中是不可接受的。尽管它曾因计算效率高而被大量使用，但因其抗碰撞性不足，逐渐被弃用。

2. **hiding（隐匿性，单向不可逆）**：

- 原理：从哈希值几乎无法反向推导出原始输入数据。并且要求输入空间足够大，数据分布均匀。如果输入空间小或分布不均匀，攻击者就有可能通过蛮力求得能产生特定哈希值的输入。

- 应用：

- **digital commitment/digital equivalent of a sealed envelop（数字承诺 / 密封信封的数字等价物）**：例如在预测类场景中，预测结果不能提前公开。可以先对预测结果进行哈希运算，将哈希值公开，之后再公开原始预测结果，其他人通过对原始结果进行哈希计算并与之前公开的哈希值对比，就能验证结果的一致性和未被篡改。

- **数字签名**：把预测结果作为输入，通过特定的哈希运算得到哈希值，再用私钥对该哈希值进行签名。签名后的信息可用于验证数据来源及完整性。

- **H(x||nonce)**：在结果后拼接一个随机值 nonce。这常用于区块链挖矿等场景，通过改变 nonce 值，使哈希运算结果满足特定条件。例如在比特币挖矿中，通过不断调整 nonce 来使区块头的哈希值满足一定难度要求。

3. **puzzle friendly（谜题友好性）**：

- 特性：哈希值事先不可预测。对于任意给定的哈希值，在不知道输入的情况下，无法通过特定方法快速找到能产生该哈希值的输入数据。

- 应用：

- **挖矿**：以比特币挖矿为例，矿工需要找 nonce，使得 H (block header) <= target（目标值）。这个过程没有捷径，只能大量地去尝试不同的 nonce 值，这就是所谓的 proof of work（工作量证明）。通过这种方式，保证了区块链系统中新区块生成的公平性和安全性。

- **difficult to solve, but easy to vertify（求解困难，但验证容易）**：矿工找到满足条件的 nonce 和哈希值后，其他节点可以很容易地通过重新计算哈希值并与目标值对比来验证其正确性。

- **SHA - 256——secure hash algorithm（安全哈希算法）**：是比特币等区块链项目广泛使用的哈希算法，具有较高的安全性和计算效率，能有效保证区块链中数据的完整性和哈希计算的安全性。

## 签名

在区块链的去中心化环境中，签名机制是确保交易安全和身份认证的关键环节：

- **去中心化特性**：签名机制不依赖于任何中心化的机构来验证身份或授权交易，而是通过密码学原理在网络节点间实现自我验证。

- **（public key，private key）（公钥，私钥）**：这是基于非对称加密算法产生的一对密钥。

- **asymmetric encryption algorithm（非对称加密算法）**：使用一对密钥，即公钥和私钥。与对称加密算法不同，对称加密算法加密和解密使用相同的密钥，而在非对称加密中，加密用公钥，解密用私钥。

- **优势**：公钥不用保密，可以广泛公开传播，私钥只要保存在本地，极大地解决了密钥分发不方便的问题。例如在区块链网络中，每个节点都可以将自己的公钥公开给其他节点，用于接收加密信息或验证签名。

- **类比**：公钥相当于银行卡账号，可公开示人用于接收资金等操作；私钥相当于密码，必须严格保密，只有拥有私钥的人才能对相关资产进行操作。

- **签名与验证**：签名是用私钥对数据（通常是数据的哈希值）进行处理，生成一个签名信息。验证时则是用公钥对签名信息进行验证，以确认数据是否由对应的私钥持有者发出且未被篡改。例如在比特币交易中，交易发起者用自己的私钥对交易信息进行签名，其他节点收到交易后，用发起者的公钥验证签名，从而确定交易的真实性和有效性。

- **a good source of randomness（良好的随机数来源）**：私钥的生成通常基于随机数，这些随机数为签名过程提供了不可预测性，进一步增强了签名的安全性。

比特币一般是对 message 先哈希，然后再签名。这是因为哈希值具有固定长度且能唯一代表原始消息的特征，对哈希值签名比对原始消息直接签名更高效且能保证消息完整性。如果原始消息被篡改，其哈希值会发生变化，而基于原哈希值的签名将无法通过验证。

---

# 2. 数据结构

## 1. Hash Pointers（哈希指针）

哈希指针是区块链数据结构中的一个关键概念，它不仅保存了结构体的地址，还保存了该结构体的哈希值。这一特性使得哈希指针能够检测数据是否被篡改。

在区块链中，一个个的区块通过哈希指针连接形成链表结构。其独特之处在于：“block chain is a linked list using hash pointer”（区块链是使用哈希指针的链表），从创世区块（genesis block）开始，一直连接到最新的区块（most recent block）。

### 好处 - Tamper - Evident Log（防篡改日志）
这种基于哈希指针的链表结构形成了一种防篡改日志。因为每个区块的哈希指针不仅指向了前一个区块的地址，还包含前一个区块内容的哈希值。如果对前面任何一个区块的内容进行篡改，该区块的哈希值就会发生变化。由于后续区块的哈希指针依赖于前序区块的哈希值，所以前面区块的任何改动都会导致后面所有区块的哈希指针发生变化，正所谓 “牵一发而动全身”。这样，区块链中的数据一旦被记录，就很难被篡改而不被发现，保证了数据的完整性和可信度。

## 2. Merkle Tree（默克尔树）
默克尔树是一种特殊的二叉树结构，与普通二叉树的区别在于它使用哈希指针代替普通指针。

### 结构与原理

如给定的图片
![image.png](https://raw.githubusercontent.com/Frank-whw/img/main/blog/202501201737099.png)

所示，默克尔树的底层节点（data blocks）通常是交易（tx），可以是块头或者块身。其中，块头（block header）包含根哈希值，但不包含交易的具体内容；块身（block body）则包含交易的列表。

### 好处 - 数据完整性检测
默克尔树最大的好处在于，只要知道根哈希（root hash），就能检测出下面任何部分是否发生变化。因为默克尔树的构建方式是将底层节点的哈希值两两组合再进行哈希计算，逐层向上，最终得到根哈希。如果底层任何一个数据块（交易）发生改变，其哈希值就会改变，进而导致上层节点的哈希值也依次改变，最终根哈希值也会不同。所以通过对比当前根哈希值与之前记录的根哈希值，就能判断底层数据是否被篡改。

### Merkle Proof（默克尔证明）

默克尔树提供了默克尔证明机制。在比特币（BTC）中，节点分为两类：全节点和轻节点。全节点保存了完整的区块链数据，包括所有的区块头和区块体；而轻节点只保存一个区块头（block header）。

轻节点相当于手机上的比特币客户端，用户通过轻节点发送交易信息（tx）。由于轻节点没有完整的交易数据，所以它会向全节点请求验证。验证过程中，轻节点通过一层一层的 SPV（Simple Payment Verification，简单支付验证），本地计算部分哈希值，并向全节点请求得到其他哈希值，然后向上一直计算到根哈希，最后将计算得到的根哈希与自己保存的区块头中的根哈希值进行比较，以此判断该交易是否被记录在区块链上。轻节点在验证过程中，只能查询到与该交易相关路径中的哈希值。

### 安全性分析
1. **关于篡改证明数据**：有人可能会想，能否为了证明自己的交易已记录在区块链上，却又篡改证明过程中需要用到的其他交易，导致证明失败。实际上这种做法是不可行的。因为在默克尔树结构下，若要修改某个节点数据以达到篡改证明的目的，不仅需要修改该节点本身，还需要修改其上层所有依赖该节点哈希值的节点，直至根节点。这意味着几乎要修改整棵树，甚至影响到整条区块链，从算力消耗上来说是不现实的。
2. **影响证明正确性的因素**：在上述条件下，所提供的默克尔证明中辅助哈希值必然是正确的。因为在正常的区块链网络中，全节点保存的是完整且正确的数据，轻节点从全节点获取的哈希值也是可信的。所以唯一可能影响证明正确性的因素就是验证节点（轻节点）本身，例如其软件实现是否正确、计算过程是否有误等。

### 成员证明与非成员证明
1. **Proof of Membership（成员证明）/Proof of Inclusion（包含证明）**：通过默克尔证明可以高效地验证某个交易是否包含在区块链中。由于默克尔树是二叉树结构，从叶子节点到根节点的路径长度为 log (n)（n 为叶子节点的数量），所以验证过程的时间复杂度为 log (n)，相对比较高效。
2. **Proof of Non - Membership（非成员证明）**：对于证明某个交易不在默克尔树中，传统默克尔树的验证时间复杂度为 n，呈线性关系。但是，如果节点是根据哈希值排好序的（即 sorted merkle tree，排序默克尔树），就可以通过判断某个节点的哈希值在排序中的位置，以及它旁边节点是否相邻，来判断该节点是否在这个树中。不过在比特币的默克尔树中，并不要求节点进行排序。

### 哈希指针的应用限制
哈希指针虽然在区块链数据结构中有诸多优势，但它的应用场景存在一定限制。例如，哈希指针只能用在无环的列表结构中。如果是有环结构，会出现**循环依赖**的问题，导致哈希值计算无法正常完成，破坏了哈希指针基于数据完整性和顺序性的检测机制。


---

# 3. 协议

## 方案探讨与问题分析

### 方案一：公私钥非对称加密
采用公私钥非对称加密技术，虽能保障交易的安全性，但在数字货币场景下存在严重问题。数字货币本质上是数字化信息，具有可复制性，这就导致了 “花 2 次攻击（double spending attack）”，即双花攻击。攻击者有可能利用数字货币的可复制特性，将同一笔数字资产进行多次花费，破坏了货币交易的唯一性和价值稳定性。因此，数字货币必须防范双花攻击。

### 方案二：中心化存储
该方案通过设立一个中心化的数据库，记录每个标号的货币归属，即记录每一笔钱在谁手上。从理论层面看，这种方式能够解决双花问题，因为中心化数据库可以统一管理和验证每一笔交易，确保货币的唯一性。然而，在实际应用中，这种方法过于繁琐，需要一个强大的中心机构来维护数据库，且容易引发信任问题，例如中心机构可能存在数据篡改、单点故障等风险。

### 方案三：去中心化
去中心化方案旨在构建一个无需依赖中心化机构的数字货币系统，但面临着两个关键问题：
1. **货币发行问题**：在比特币（BTC）系统中，货币发行由挖矿机制决定。挖矿过程不仅仅是简单的计算操作，它还承担着发行新比特币的重要职责。
2. **双花攻击防范问题**：比特币通过所有用户共同维护区块链来解决双花问题。区块链是一种分布式账本，每个参与者（节点）都保存了账本的副本，通过共识机制确保所有账本副本的一致性，从而有效防范双花攻击。

## 比特币交易示例与结构分析
例如，在一个简单的比特币交易流程中：
- **铸币交易（creatCoint）**：产生初始的比特币，如 `creatCoint -> A(10)`，这是一个 coinbase tx（创币交易），其中包含了 A 的公钥的哈希。这意味着 A 获得了 10 个比特币，且这笔交易作为比特币的初始来源，开启了后续的流转。
- **后续交易**：
    - `A -> B(5)`，`A -> C(5)`，这两笔交易由 A 发起，并由 A 使用自己的私钥进行签名。签名的目的是证明交易的真实性和 A 的授权，其他节点可以使用 A 的公钥来验证签名的有效性。
    - `B -> C(2)`，`B -> D(3)`，同样由 B 用私钥签名，表明 B 对这两笔交易的授权。
    - `C -> E(7)`，由 C 签名，展示了比特币在不同用户之间的流转过程。

  

在比特币交易中，每个交易分为输入和输出两部分：
- **输入部分**：需要明确币的来源，即引用之前交易的输出作为本次交易的输入，通过这种方式追溯资金的源头，确保每一笔交易的合法性和连贯性。
- **输出部分**：要给出收款方的公钥，指定这笔比特币的接收者。发送方使用接收方的公钥对交易信息进行加密，只有接收方能够使用自己的私钥解密获取交易内容。同时，发送方用自己的私钥进行签名，接收方以及其他节点可以使用发送方的公钥进行验证，确保交易确实由发送方发起且未被篡改。

  
每个交易的输入输出实际上是一段脚本，公钥也在脚本中指定。比特币脚本通过一种特殊的编程逻辑来验证交易的有效性。例如，A 的输入脚本和前面交易的输出脚本拼接在一起，如果这段拼接后的脚本能够按照比特币脚本的规则正常运行，就说明该交易是正常的。

## 比特币区块链结构
在实际的比特币系统中，每个区块包含了大量的交易，其结构通过 Merkle 树来组织，分为块头（block header）和块身（block body）：

- **块头（block header）**：包含关键信息，如 `version`（版本号，用于标识区块的协议版本）、`hash of previous block header`（前一个区块头的哈希值，通过哈希指针将区块链中的各个区块连接起来，形成链式结构，保证了数据的顺序性和可追溯性）、`merkle root hash`（默克尔树的根哈希值，用于快速验证区块内所有交易的完整性）、`target`（目标哈希值，决定了挖矿的难度，矿工需要找到一个哈希值小于该目标值的区块头，才能获得记账权）、`nonce`（一个 4 字节的随机数，矿工通过不断调整 nonce 值来尝试找到符合要求的哈希值）。通过计算 `H(block header) <= target`（其中 `H` 表示哈希函数），只有满足这个条件的区块头才是有效的。这里的 `nBits` 是一种表示目标值的紧凑格式，用于在不同节点间统一表示目标难度。值得注意的是，只有块头有指向前一个块头的哈希指针，形成了区块链的基本链式结构。那么，有人可能会问，如果只对块头取哈希，而块身不取哈希，如何保证块身内容不被修改呢？实际上，块身中的所有交易通过 Merkle 树结构组织，块头中的 Merkle 根哈希值是根据块身中所有交易计算得出的。如果块身内容发生任何改变，重新计算得到的 Merkle 根哈希值必然会改变，从而导致块头的哈希值改变，使得该区块不再满足 `H(block header) <= target` 的条件，因此 Merkle 根哈希能够保证块身内容的完整性和不被篡改。
- **块身（block body）**：主要包含交易列表，即该区块所打包的所有比特币交易。


比特币网络中的节点分为两种类型：
- **全节点（full node）**：也称为完全验证节点，它保存了完整的区块链数据，包括所有的区块头和区块体，能够独立验证每一笔交易的合法性，参与区块链的构造和维护，对整个区块链网络的安全和稳定起着关键作用。
- **轻节点（light node）**：无法独立验证交易的合法性，因为它没有存储完整的区块链数据，没有参与区块链的实际构造过程。轻节点主要利用查询功能，通过向全节点请求相关信息来验证交易，例如在简单支付验证（SPV）过程中，轻节点通过向全节点获取部分哈希值等信息，结合本地计算来验证交易是否被记录在区块链上。

## 交易写入区块链与共识机制

### 交易如何写入区块链

区块链本质上是一个去中心化的账本，要将交易写入区块链，就需要在分布式网络中的众多节点间达成共识，即对账本内容的一致性认可。这里涉及到分布式共识（distributed consensus）的概念，类似于分布式哈希表（distributed hash table）的全局哈希表结构，其中每个节点都保存了一份 “key - value pair” 形式的账本副本。然而，在分布式系统中达成共识并非易事，存在一些不可能结论：
1. **FLP 定理**：在一个异步（asynchronous）系统里，网络传输时延没有上限，哪怕只有一个用户是故障（faulty）的，也没有办法达成共识。这就好比著名的拜占庭将军问题，在分布式系统中，各个节点就像拜占庭军队中的将军，他们需要在进攻或撤退等决策上达成一致，但由于存在故障节点或恶意节点的干扰，使得达成共识变得极为困难。
2. **CAP 定理**：在分布式系统中，一致性（consistence）、可用性（availability）和容错性（partition tolerance）这三个性质不可能同时满足。在实际应用中，往往需要根据具体场景对这三个特性进行权衡。

  

在比特币系统中，为了在大多数节点是好的，少部分是坏的情况下达成共识，采用了以下方法：
### 比特币的共识机制

1. **投票方式的思考与问题**：
    - **基于账号数量投票**：最初设想通过账号数量来投票决定账本内容的共识。但这种方式存在严重的效率问题，恶意攻击者可能会进行 “行政不作为”，即不断发起攻击并投票，导致正常节点没有时间进行挖矿等有效操作。此外，在比特币系统中创建账号非常容易，这就引发了女巫攻击（sybil attack），攻击者可以创建大量虚假账号来控制投票结果，破坏共识机制。
    - **基于算力投票**：比特币采用了基于算力的投票方式来解决上述问题。在挖矿过程中，矿工需要找到一个合适的 `nonce`，使得 `H(block header) <= target`。这个过程需要大量的计算资源，即算力。只有找到符合要求的 `nonce` 的节点才有权力发布下一个区块，这个权力被称为记账权，即在区块链这个去中心化的账本里写入下一个区块的权利。其他节点收到这个新区块后，会验证该区块的合法性，例如检查 `block header` 的内容，包括 `nBits` 是否正确，确保其符合比特币网络设定的规则和难度要求。
2. **区块的接受与分叉问题**：
    - **区块插入位置与合法性**：新产生的区块必须插在最长合法链上。如果将区块插在中间，不在最长合法链上，就会出现问题。因为节点对区块合法性的判断主要依据前面交易的情况，如果在该区块之后仍有交易，可能会导致双重支付问题，即分叉攻击（forking attack），攻击者试图回滚某个已经发生的交易，从而实现双花。因此，只有拓展最长合法链的区块才会被大多数节点接受。
    - **同时发布合法区块的处理**：当两个节点同时发布合法区块时，比特币网络会看谁能够抢先找到下一个区块。先挖出下一个合法区块且被网络认可的节点，不仅能获得该区块的记账权，还会得到比特币奖励。这就激励了矿工不断提高算力，以争取获得记账权和奖励。
3. **竞争记账权的原因 - 出块奖励**：  
    竞争记账权的主要动力是出块奖励（block reward）。挖出新区块的节点在 `block body` 中会有一个特殊的交易，即铸币交易（coinbase transaction），这是发行新比特币的唯一方法。在比特币系统的初始阶段，每一个区块的出块奖励为 50 BTC，随着时间推移和区块数量的增加，奖励会逐渐减半，如经过 21 万个区块后，奖励变为 25 BTC，目前大约为 12.5 BTC。中本聪在比特币创世区块中首次引入了这种奖励机制，据说比特币第一次与现实世界产生价值交换时，是用 2 万个比特币购买了一个披萨，这标志着比特币从虚拟概念走向了实际应用。需要注意的是，在分叉点上得到的比特币是没有用的，因为只有在最长合法链上的比特币才被整个网络认可和接受。


通过上述基于算力的共识机制，比特币实现了去中心化账本内容的一致性，使得挖矿（mining）这一过程类似于寻找数字黄金，矿工们通过争夺记账权，不断为区块链网络添加新的区块，维护着比特币系统的稳定运行，同时也使得女巫攻击在这种机制下无法对系统造成实质性破坏。


---
