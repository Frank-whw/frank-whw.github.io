## 1. 交易账本类型

### Transaction - based Ledger（基于交易的账本）
在这种账本模式下，系统并不直接记录某人具体的余额。而是通过维护 **UTXO**（Unspent Transaction Output，未花费交易输出）来管理资产。一个交易可能会产生多个输出，这些输出在未被后续交易作为输入消耗之前，都被视为 UTXO。


维护 UTXO 至关重要，其主要作用是检测**双花攻击**（double spending）。通过记录所有未花费的交易输出，系统能够快速判断每一笔新交易是否试图重复花费已被使用的输出。这种方式极大地节省了检测时间，提高了系统效率。
在每一笔交易中，遵循 total inputs = total outputs。transaction fee通常金额较小。
随着比特币的发展，大约每 **21** 万个区块（差不多 4 年），区块奖励会减半。
当区块奖励逐渐减少到一定程度后，交易费将成为矿工的主要收入来源。

### Account - based Ledger（基于账户的账本）

  

![image.png](https://raw.githubusercontent.com/Frank-whw/img/main/blog/202501221237867.png)
这种账本模式聚焦于每个账户的余额变动。与基于交易的账本不同，它直接记录每个账户的资产数量，通过对账户的增减操作来反映交易情况。

## 2. 挖矿相关概率过程

### Bernoulli Trail（伯努利试验）与 Bernoulli Process（伯努利过程）


伯努利试验是一种具有二元结果的随机试验，例如掷硬币，结果只有正面或反面两种。而伯努利过程则是一系列相互独立的伯努利试验，具有无记忆性（memoryless）。
这意味着每次试验的结果都不受之前试验结果的影响。

### Poisson Process（泊松过程）
在比特币挖矿中，泊松过程用于保证挖矿的公平性。它与指数分布相关，比特币系统平均出块时间设定为 10 分钟。这是基于泊松过程的特性，使得在一段时间内，每个矿工都有相对公平的机会挖出新区块。
如果挖矿过程不是无记忆性的 puzzle，那么算力强的矿工会有**不成比例的优势**。例如，假设挖矿难度与之前的挖矿结果有关，算力强的矿工可能凭借之前的成功经验或积累，更容易预测和满足后续的挖矿条件，从而大大增加他们挖到新区块的概率，破坏了系统的**公平性**。

### 比特币总量计算

通过几何级数计算可得比特币的总量。已知最初每个区块的奖励为 50 BTC，每 21 万个区块奖励减半，即：  
![image.png](https://raw.githubusercontent.com/Frank-whw/img/main/blog/202501221238214.png)

所以比特币的总数只有 2100 万，比特币系统通过挖矿机制来保障其安全性（**bitcoin is secured by mining**）。

## 3. 分叉攻击与确认机制
- 为避免分叉攻击（forking attack）导致**交易回滚**，比特币采用了多确认机制。在比特币系统中，缺省的是六个确认（six confirmation）。这意味着一笔交易需要在区块链上被六个新区块确认后，才被认为是相对安全、不可撤销的。然而，所谓的 irrevocable ledger（不可撤销账本）只是一种概率上的保证，并不能绝对避免分叉攻击的影响。

- 在实际应用中，零确认（zero confirmation）的交易也比较普遍。虽然这种交易没有经过多个区块的确认，但由于分叉攻击的代价是一个出块奖励，对于大多数攻击者来说，实施分叉攻击的成本较高，所以在一定程度上也能维持交易的相对稳定性。

## 4. 恶意节点与区块限制

- 恶意的节点可以选择不将合法的交易写入区块，不过这对整个系统的影响相对不大。因为每个区块的大小是有限制的，最大为 1M。这一限制一方面防止了单个区块包含过多数据导致网络传输和处理负担过重，另一方面也限制了恶意节点通过大量填充无效数据来破坏系统的可能性。


## 5. Selfish Mining（自私挖矿）

在正常情况下，矿工挖到一个区块后会立即发布。然而，Selfish mining可被用于分叉攻击，但前提是恶意节点的算力大于 51%。采用自私挖矿策略时，恶意节点挖到区块后不会立即发布，而是继续在这个私有的分支上挖矿。这样做的好处是减少了与其他矿工的竞争，因为其他矿工不知道这个私有分支的存在，仍在原有的链上挖矿。但风险在于，如果其他矿工在原链上也挖出了足够多的区块，可能会导致出现等长链的情况，使得整个区块链网络产生混乱，影响系统的正常运行。